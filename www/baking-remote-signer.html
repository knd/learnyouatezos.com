<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Learn You a Tezos for Much Prosperity</title>
  <link rel="shortcut icon" href="/static/img/blkstar.co.logo_128.bt.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <meta name="description" content="...">
  <meta name="author" content="Matthew Smith">
  <title>Latte, Jed?</title>
  <link rel="stylesheet" href="/static/css/normalize.css?v=1.0">
  <link rel="stylesheet" href="/static/css/dracula.css?v=1.0">
  <link rel="stylesheet" href="/static/css/styles.css?v=1.0">
</head>
<body class="">
  <div id="background">
    <div id="content">

<h1>Baking: Remote Signer</h1>

<div class="navigation navigation-top">
  <ul>
    <li style="text-align: left">
      
        <a id="prevlink" href="/baking-tezos-privately.html">Baking Tezos Privately</a>
      
    </li>
    <li style="text-align: center">
      <a href="/toc.html">Table of Contents</a>
    </li>
    <li style="text-align: right">
      
        <a id="nextlink" href="/baking-tezos-publicly.html">Baking Tezos Publicly</a>
      
    </li>
  </ul>
</div>

<h3 id="remote-signers">Remote signers</h3>
<p><highlight>[TODO: Tie this into previous discussion of security and baker topology]</highlight></p>
<h3 id="whyanhsm">Why an HSM?</h3>
<p>While baking is relatively straightforward, <em>key security</em> is not and necessitates an approach that usually means separating private keys from a baker, ideally residing in a hardware security module (HSM).</p>
<p>An HSM's primary security feature is that signing (and other cryptographic) operations take place on a dedicated hardward chip that contains your private key and handles operations <em>without your private key leaving the device.</em> The key material is not exposed to the attached computer, meaning a compromise of that computer does not leak your private key.</p>
<p>Low cost, consumer-grade HSMs are common in the cryptocurrency world, with Ledger Nano being probably the most common. While Tezos signing (and wallet) software is avaiable for the Ledger, it requies a physical USB connection to a computer, requiring either the signing computer or the entire baking node reside in your home or office.</p>
<p>While this can be simple and low-cost, it does require an always-available internet connection, the ability to open ports to the public network and an uninterruptible power supply. In practice it's not easy to achieve high availability with this setup. Lots of things can go wrong, especially when the setup is unattended (e.g., you're on holiday).</p>
<p>A cloud signer with an attached HSM is a solution to this problem, but dedicated HSMs are expensive to operate, out of the price range of any but the largest baking operations. </p>
<p>However, Google Cloud KMS and Azure Key Vault have started to offer per-use pricing that makes HSM-backed signing operations very inexpensive, making them affordable for even very small bakers.</p>
<h3 id="whyazure">Why Azure?</h3>
<p>As both Google and Microsoft's offerings are compatible with Tezos, the main consideration is whether or not private keys can be backed up. Azure allows for it and Google does not.</p>
<p>It is <em>strongly not recommended</em> to use a cloud HSM service that does not allow for backing up of private keys. Ask yourself these questions:</p>
<ol>
<li>Do you trust this company to <em>never</em>, under any circumstances, lose your private key?</li>
<li>Do you trust this company to never lock your account for any reason?</li>
</ol>
<p>The answer to both of those has to be no.</p>
<p><note>
To be precise, Azure does not allow you to back up your HSM-generated keys. The backup functionality will only allow you to move your key within the same availability region. However, they do allow you to generate your own keys and import them, which is what we're going to do.
</note></p>
<h3 id="twovmsandanhsm">Two VMs and an HSM?</h3>
<p>This setup calls for a separate baker and signer VM. It is possible run the signing service on the same VM as the baker, so why not do that? The answer is it's less secure.</p>
<ol>
<li>An attacker who could gain access to your baker could sign any operation, including moving all of your XTZ to another address</li>
<li>Your baker <em>may</em> be known to the rest of the network, increasing the chances it is targeted for attack</li>
<li>Running a separate signer allows you to whitelist baking and endorsing operations and require intervention for other operations (transfers, voting, etc.)</li>
<li>A separate signer requires that <em>two</em> VMs are compromised before signing operations could be done by a rogue actor</li>
</ol>
<p>Since your signer will only be known to your baker, the baker itself would have to be accessed to discover the IP address. After that, your signer VM would also have to be compromised. </p>
<p>To help offset this, the signing software provided here is very lightweight and can be run on the cheapest available VM.</p>
<p>This also allows for the entire signer to reside on Azure (which simplifies authentication for the signer and makes it more secure) while allowing you to run your baker node on another service, as the author does.</p>
<h3 id="getting-started-with-azure">Getting started with Azure</h3>
<h3 id="getanazureaccount">Get an Azure account</h3>
<p>If you don't already have one, go here <a href="https://azure.microsoft.com/en-us/free">https://azure.microsoft.com/en-us/free</a> to get a new Azure account.</p>
<p>You'll likely have to go through a privacy-violating ID verification with a phone number <em>and</em> credit card, but given that you'll be supplying them with billing information anyway, it's a moot point.</p>
<p>It is <em>strongly recommended</em> that you set up two-factor authentication (2FA) for the Microsoft account you use to access Azure. Someone gaining acess to you Azure account could change your security settings and allow access to your signer from a rogue computer. More info <a href="https://support.microsoft.com/en-us/help/12408/microsoft-account-how-to-use-two-step-verification">here</a>.</p>
<h3 id="installazurecli">Install Azure CLI</h3>
<p>It's recommended that you install the CLI on your local machine or on a local VM. It is <em>not recommended</em> to install the cli on the remote signer you'll provision nor your baker's VM. We'll be authenticating the CLI and having those credentials on a remote machine can be a security issue. </p>
<p><note>
Running a VM on your local computer <em>do not</em> protect you against key loggers and other forms of malicious monitoring. If you are unsure of your local computer's security, you should at least do a clean install of your OS before continuing.
</note></p>
<pre><code class="hljs bash language-bash">curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
</code></pre>
<p>You may want to download the script and review it before running it. Alternately, you can install manually as outlined here: <a href="https://docs.microsoft.com/en-us/cli/azure/install-azure-cli-apt?view=azure-cli-latest">https://docs.microsoft.com/en-us/cli/azure/install-azure-cli-apt?view=azure-cli-latest</a>.</p>
<p><note>
If you see errors or warnings about default locale go to <a href="/appendix.html#ubuntu-locale-fix">learnyouatezos.com/appendix.html#ubuntu-locale-fix</a> to find a fix.
</note></p>
<p>Check the version of <code>az</code> and ensure it has some meaningful output and you don't get any errors:</p>
<pre><code class="hljs bash language-bash">az --version
</code></pre>
<h3 id="authenticateanddetermineregion">Authenticate and determine region</h3>
<p>Now, login:</p>
<pre><code class="hljs bash language-bash">az login
</code></pre>
<p>You should get a response that looks like:</p>
<pre><code class="hljs plaintext language-plaintext">To sign in, use a web browser to open the page https://microsoft.com/devicelogin and enter the code XXXXXXXXX to authenticate.
</code></pre>
<p>Open that page, copy and paste the code and select the account you want to use. Wait a moment and you should get some json as a response to <code>az login</code>:</p>
<pre><code class="hljs json language-json">[
  {
    "cloudName": "AzureCloud",
    ...
  }
]
</code></pre>
<p>Before you get started with the cli, decide what region to set up your signer in. Usually, you'll want to set up as close to your baker as possible.</p>
<p>A list of regions supporting Key Vault is here <a href="https://azure.microsoft.com/en-us/global-infrastructure/services/?products=key-vault">https://azure.microsoft.com/en-us/global-infrastructure/services/?products=key-vault</a>, but this list does not contain the identifiers that the cli expects.</p>
<p>To find these, run the following command:</p>
<pre><code class="hljs bash language-bash">az account list-locations | grep -A 5 <span class="hljs-string">"Southeast Asia"</span>
</code></pre>
<p>Replace "Southeast Asia" with the region you prefer from the previous list. You should get a response like:</p>
<pre><code class="hljs bash language-bash"><span class="hljs-string">"displayName"</span>: <span class="hljs-string">"Southeast Asia"</span>,
<span class="hljs-string">"id"</span>: <span class="hljs-string">"/subscriptions/&lt;UUID&gt;/locations/southeastasia"</span>,
<span class="hljs-string">"latitude"</span>: <span class="hljs-string">"1.283"</span>,
<span class="hljs-string">"longitude"</span>: <span class="hljs-string">"103.833"</span>,
<span class="hljs-string">"name"</span>: <span class="hljs-string">"southeastasia"</span>,
<span class="hljs-string">"subscriptionId"</span>: null
</code></pre>
<p>In this case the identifier is the name field <code>southeastasia</code>. Copy that down as you'll need it for the next step.</p>
<h3 id="createaresourcegroup">Create a resource group</h3>
<p>Create a resource group, giving it the name of your choice and using the location we've just determined.</p>
<pre><code class="hljs bash language-bash">az group create \
    --name TezosSigner-ResourceGroup \
    --location southeastasia
</code></pre>
<p>You should get a response that looks like this:</p>
<pre><code class="hljs bash language-bash">{
  <span class="hljs-string">"id"</span>: <span class="hljs-string">"/subscriptions/&lt;UUID&gt;/resourceGroups/TezosSigner-ResourceGroup"</span>,
  <span class="hljs-string">"location"</span>: <span class="hljs-string">"southeastasia"</span>,
  <span class="hljs-string">"managedBy"</span>: null,
  <span class="hljs-string">"name"</span>: <span class="hljs-string">"TezosSigner-ResourceGroup"</span>,
  <span class="hljs-string">"properties"</span>: {
    <span class="hljs-string">"provisioningState"</span>: <span class="hljs-string">"Succeeded"</span>
  },
  ...
}
</code></pre>
<p>If you need to delete the resource group, you can use the command:</p>
<p><warning>
This will delete <em>everything</em> inside the resource group. Only use this command when trying things out.
</warning></p>
<pre><code class="hljs bash language-bash">az group delete \
    --name <span class="hljs-string">"TezosSigner-ResourceGroup"</span> \
    --yes
</code></pre>
<h3 id="setting-up-a-signer-vm">Setting up a signer VM</h3>
<h3 id="createavirtualmachine">Create a virtual machine</h3>
<p>Next let's create the VM we'll be running our signer in. We use the <code>az vm create</code> command for this. We won't do anything with this until later, but we'll need to get its public IP so we can set up the firewall of our Key Vault.</p>
<pre><code class="hljs bash language-bash">az vm create \
    --name TezosSigner-VM \
    --resource-group TezosSigner-ResourceGroup \
    --image Canonical:UbuntuServer:18.04-LTS:latest \
    --size Standard_B1s \
    --storage-sku Standard_LRS \
    --admin-username deploy \
    --authentication-type ssh \
    --nsg-rule ssh \
    --ssh-key-values ~/.ssh/id_rsa.pub \
    --assign-identity
</code></pre>
<p><note>
If you do not have a keypair set up for ssh (i.e., you don't have an <code>id_rsa.pub</code> present, run <code>ssh-keygen</code> first to create one.
</note></p>
<p>You should get output that looks like this:</p>
<pre><code class="hljs bash language-bash">{
  ...
  <span class="hljs-string">"identity"</span>: {
    <span class="hljs-string">"principalId"</span>: <span class="hljs-string">"&lt;UUID&gt;"</span>,
    ...
  },
  ...
}
</code></pre>
<p>Record the <code>principalId</code> so we can assign it to our Key Vault.</p>
<p>We'll also need to get the VM's public IP:</p>
<pre><code class="hljs bash language-bash">az vm list-ip-addresses \
    --name TezosSigner-VM \
    --resource-group TezosSigner-ResourceGroup
</code></pre>
<p>Test that you can log into your VM:</p>
<pre><code class="hljs bash language-bash">ssh deploy@&lt;public IP address&gt;
</code></pre>
<p>You should have logged in successfully.</p>
<h3 id="secureyourvm">Secure your VM</h3>
<p>Become root user:</p>
<pre><code class="hljs bash language-bash">sudo -i
</code></pre>
<p>Download and run this script to further secure your VM:</p>
<pre><code class="hljs bash language-bash">curl -sO https://gist.githubusercontent.com/lattejed/94488cb5d0004af16c0c99b1c92fbdb6/raw/ubuntu_basic_setup_az.sh &amp;&amp; bash ubuntu_basic_setup_az.sh
</code></pre>
<p>Feel free to download it first and review it. It does the following:</p>
<ol>
<li>Sets a password for your <code>deploy</code> user</li>
<li>Makes your sudoers file more secure</li>
<li>Upgrades all installed packages </li>
<li>Installs fail2ban to block machines attacking your ssh port</li>
<li>Enables unattended security upgrades</li>
<li>Makes your ssh settings more secure </li>
</ol>
<p>Exit the root user account:</p>
<pre><code class="hljs bash language-bash"><span class="hljs-built_in">exit</span>
</code></pre>
<p>If you need to delete the VM while testing, use the following command:</p>
<pre><code class="hljs bash language-bash">az vm delete \
    --name <span class="hljs-string">"TezosSigner-VM"</span> \
    --resource-group <span class="hljs-string">"TezosSigner-ResourceGroup"</span> \
    --yes
</code></pre>
<h3 id="setting-up-your-key-vaults">Setting up your Key Vaults</h3>
<h3 id="createakeyvault">Create a Key Vault</h3>
<p>Next, create a Key Vault that will contain your imported keys.</p>
<pre><code class="hljs bash language-bash">az keyvault create \
    --name TezosSigner-KeyVault \
    --resource-group TezosSigner-ResourceGroup \
    --location southeastasia \
    --sku premium
</code></pre>
<p><note>
<code>--sku premium</code> is mandatory as that will allow for HSM operations.
</note></p>
<p>You should get output that looks like this:</p>
<pre><code class="hljs json language-json">{
  ...
  "properties": {
    ...
    "vaultUri": "https://tezossigner-keyvault.vault.azure.net/"
  },
  ...
}
</code></pre>
<p>Record your vault URI.</p>
<p><note>
Make sure you copy down your vault URI as you'll need it to run your signer.
</note></p>
<p>If you need to delete the key vault, you can use the command:</p>
<pre><code class="hljs bash language-bash">az keyvault delete \
    --name TezosSigner-KeyVault
</code></pre>
<h3 id="setupkeyvaultfirewall">Set up Key Vault firewall</h3>
<p>This is a multi-step process, but is <em>strongly recommended</em> as it will secure the connection between your signer VM and your Key Vault.</p>
<p>First, get a list of virtual networks in your resource group:</p>
<pre><code class="hljs bash language-bash">az network vnet list \
    --resource-group TezosSigner-ResourceGroup
</code></pre>
<p>Your output will look like this:</p>
<pre><code class="hljs json language-json">[
  {
    ...
    "name": "TezosSigner-VMVNET",
    ...
    "subnets": [
      {
        ...
        "name": "TezosSigner-VMSubnet",
        ...
      }
    ],
    ...
  }
]
</code></pre>
<p>We want to record the virtual network name as well as the subnet name.</p>
<p>Next, we need to add a Key Vault service endpoint to our subnet. Use the following command, filling in your values as necessary:</p>
<pre><code class="hljs bash language-bash">az network vnet subnet update \
    --resource-group TezosSigner-ResourceGroup \
    --vnet-name TezosSigner-VMVNET \
    --name TezosSigner-VMSubnet \
    --service-endpoints <span class="hljs-string">"Microsoft.KeyVault"</span>
</code></pre>
<p>Next, add the subnet to your Key Vault's firewall:</p>
<pre><code class="hljs bash language-bash">az keyvault network-rule add \
    --name TezosSigner-KeyVault \
    --vnet-name TezosSigner-VMVNET \
    --subnet TezosSigner-VMSubnet
</code></pre>
<p>Then add the public IP address of your signer VM:</p>
<pre><code class="hljs bash language-bash">az keyvault network-rule add \
    --name TezosSigner-KeyVault \
    --ip-address &lt;public IP address of signer VM&gt;
</code></pre>
<p>To activate the firewall, set the default action to <code>Deny</code>:</p>
<pre><code class="hljs bash language-bash">az keyvault update \
    --name TezosSigner-KeyVault \
    --default-action Deny
</code></pre>
<p>To ensure your firewall is active, run the following command:</p>
<pre><code class="hljs bash language-bash">az keyvault network-rule list \
    --name TezosSigner-KeyVault
</code></pre>
<p>Your output should look like this:</p>
<pre><code class="hljs json language-json">{
  "bypass": "AzureServices",
  "defaultAction": "Deny",
  "ipRules": [
    {
      "value": "&lt;public IP address of VM&gt;"
    }
  ],
  "virtualNetworkRules": [
    {
      "id": "/&lt;path&gt;/tezossigner-vmvnet/subnets/tezossigner-vmsubnet",
      ...
    }
  ]
}
</code></pre>
<p>Ensure that the default action is <code>Deny</code> and that your subnet and signer's IP address are listed.</p>
<h3 id="setkeyvaultserviceprincipal">Set Key Vault service principal</h3>
<p>This will authorize our VM to access our Key Vault. When we created our VM, we used the flag <code>--assign-identity</code> to create an identity suitable for this purpose.</p>
<p>To connect these two, use the following command, adding our the UUID of the service principal that we recorded when we created our VM.</p>
<pre><code class="hljs bash language-bash">az keyvault <span class="hljs-built_in">set</span>-policy \
    --name TezosSigner-KeyVault \
    --key-permissions get sign \
    --object-id &lt;VM service principal ID&gt;
</code></pre>
<h3 id="generating-private-keys">Generating private keys</h3>
<p><warning>
Key security is a very big topic. The guidelines here offer one possible way to securely create and backup keys. They are not bulletproof and only represent an acceptable level of security for the author, for the author's own needs. It is strongly recommended that you research best practices on your own. If your private keys are controlling non-trivial amounts of XTZ, you should consider hiring a security consultant.
</warning></p>
<p>To generate and back up keys securely, we're going to use the following procedure:</p>
<ol>
<li>Download and create a fresh installation of Ubuntu 18.04 on a USB drive</li>
<li>Run that on an air-gapped computer</li>
<li>Create strong passphrase using <code>openssl</code> to encrypt our key</li>
<li>Create our key using <code>openssl</code></li>
<li>Back up our key and passphrase in separate locations</li>
<li>Wipe our USB key</li>
</ol>
<p>This procedure is not flawless, but it is what the author considers acceptable and uses for his own keys. </p>
<h3 id="downloadubuntu1804">Download Ubuntu 18.04</h3>
<p>We're going to first download Ubuntu 18.04 <em>desktop</em> edition. It has to be the desktop edition in order to run it as a live CD (USB).</p>
<p>Search for "Ubuntu download". A link is not provided here as that opens up an avenue for attack. Ensure that the link you follow is on <code>https://ubunutu.com</code> and that your browser indicates that it is a secure connection. The actual download should be labeled "Ubuntu 18.04.2 LTS". </p>
<p>On that page should be instructions for verifying the download once it is complete. It will look something like:</p>
<p>On Linux:</p>
<pre><code class="hljs bash language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX *ubuntu-18.04.2-desktop-amd64.iso"</span> | sha256sum --check
</code></pre>
<p><note>
If your local machine doesn't have <code>sha256sum</code> installed, you can use <code>shasum</code> in its place. The latter should be available on many Linux distros and macOS.
</note></p>
<p>Make sure you get a result like:</p>
<pre><code class="hljs bash language-bash">ubuntu-18.04.2-desktop-amd64.iso: OK
</code></pre>
<h3 id="creatingausbdrive">Creating a USB drive</h3>
<p>You'll need a USB drive that will fit the ISO you downloaded. Plug that into your computer and run the following command:</p>
<p><note>
The <code>diskutil</code> command is macOS-specific. If you are on Linux, use <code>sudo fdisk -l</code> instead.
</note></p>
<pre><code class="hljs bash language-bash">diskutil list
</code></pre>
<p>You'll get a lot of output, look for something like:</p>
<pre><code class="hljs bash language-bash">/dev/disk2 (external, physical) 
</code></pre>
<p>Pull the drive out. Ensure that it's <em>missing</em> this time:</p>
<pre><code class="hljs">diskutil <span class="hljs-built_in">list</span>
</code></pre>
<p>If it's missing, that's your USB drive.</p>
<p>Plug it back in, then unmount it:</p>
<pre><code class="hljs">diskutil unmountDisk <span class="hljs-regexp">/dev/</span>disk2
</code></pre>
<p>Then write the ISO to the drive:</p>
<p><warning>
Using <code>sudo dd</code> is a destructive command. Make sure you double check the location of your USB drive as described above. Also make sure you've backed up the contents of the USB drive if they're important to you.
</warning></p>
<pre><code class="hljs">sudo dd <span class="hljs-attribute">if</span>=~/&lt;path&gt;/ubuntu-18.04.2-desktop-amd64.iso <span class="hljs-attribute">of</span>=/dev/disk2 <span class="hljs-attribute">bs</span>=1m
</code></pre>
<p>This will take a while. Eventually the command will exit and your drive will be usable.</p>
<h3 id="runonanairgappedmachine">Run on an air-gapped machine</h3>
<p>What is an air-gapped machine? That means our machine does not have the ability to connect to the internet or other networks. In this case, it should be sufficient to do two things:</p>
<ol>
<li>Unplug any LAN or other networking cables</li>
<li><em>Do not</em> connect wifi after booting from the USB drive</li>
</ol>
<p>After booting up, you should open a web browser and ensure the internet is <em>not</em> accessible.</p>
<p><warning>
For this purpose, it is <em>not</em> enough to unplug a machine with an already installed OS. We want a fresh OS <em>and</em> no network connection for this procedure.
</warning></p>
<p><note>
If you're using Mac hardware, you may need to plug in a wired keyboard and mouse as Ubuntu does not support all Mac hardware.
</note></p>
<p><note>
If you're using a new Mac with a T2 security chip, you may have to disable Secure Boot in order to boot from a USB drive. More information can be found <highlight>TODO:</highlight>
</nope></p>
<p>Plug it in and boot it up!</p>
<h3 id="generatingapassphrase">Generating a passphrase</h3>
<p>We're going to use <code>openssl</code> to generate a passphrase that we'll use to encrypt our private key. </p>
<pre><code class="hljs bash language-bash">openssl rand -base64 16
&gt; 59oER7LlKbJfNgmsPljYwg== <span class="hljs-comment"># EXAMPLE DO NOT USE</span>
</code></pre>
<p>Creating a passphrase of 16 random bytes will give us 128 bits of entropy, which should be impossible to brute force if your private keys are ever stolen. </p>
<p><warning>
<em>Do not</em> use a normal password to encrypt your private key. Using a normal password opens your key up to brute force decryption. Using 16 random <em>bytes</em> is not the same as using a password that is 16 characters long.
</warning></p>
<p>Carefull copy your passphrase to a piece of paper that you can store securely. </p>
<p><warning>
<em>Do not</em> take a photograph of your passphrase, print it out or store it in a password manager. These open up more avenues of attack than storing a hand written copy.
</warning></p>
<p>Consider writing this on paper with e.g., the following format:</p>
<pre><code class="hljs bash language-bash">59oER7LlKbJfNgmsPljYwg== <span class="hljs-comment"># EXAMPLE DO NOT USE</span>
NNLUUNULULULULLLULLULLPP
</code></pre>
<p>Where <code>N = number</code>, <code>L = lowercase</code>, <code>U = uppercase</code> and <code>P = punctuation</code>. This will prevent confusing <code>0</code> with <code>O</code> or <code>5</code> with <code>S</code> when reading it back.</p>
<p><note>
Base 58 encoding helps eliminate this ambiguity but there is no base 58 software installed on Ubuntu by default.
</note></p>
<h3 id="generatingyourkey">Generating your key</h3>
<p>You'll need to decide if you want to generate a <code>tz2</code> or <code>tz3</code> address for your baking operation. There is currently no practial difference between the two and Azure has support for both. Azure does not support <code>tz1</code> addresses.</p>
<p>To generate a <code>tz2</code> address:</p>
<pre><code class="hljs bash language-bash">openssl ecparam -genkey -name secp256k1 | openssl ec -aes256 -out secp256k1_sk.pem
</code></pre>
<p>To generate a <code>tz3</code> address:</p>
<pre><code class="hljs bash language-bash">openssl ecparam -genkey -name prime256v1 | openssl ec -aes256 -out prime256v1_sk.pem
</code></pre>
<p>You'll be prompted to enter your passphrase that was generated in the previous step.</p>
<h3 id="testingyourpassphrase">Testing your passphrase</h3>
<p>Before you copy your key to a USB drive, you should test that your passphrase was recorded correctly. </p>
<p><warning>
<em>Do not</em> copy and paste the passphrase for this step. You want to ensure that your phyiscal backup has been recorded correctly. Read it from your backup and type it in by hand.
</warning></p>
<pre><code class="hljs plaintext language-plaintext">openssl ec -check -noout -in &lt;key file&gt;.pem
</code></pre>
<p>After entering your passphrase, the response should be:</p>
<pre><code class="hljs plaintext language-plaintext">EC Key valid.
</code></pre>
<p>If it is not, start over from the beginning.</p>
<h3 id="securingyourkey">Securing your key</h3>
<p>It's strongly recommended that you back up your key redundantly (e.g., mutliple USB drives in multiple secure locations). Your passphrase should also be backed up in a <em>separate</em> secure location.</p>
<p><warning>
If you lose your key <em>or</em> your passphrase the associated <code>tz</code> address can <em>never be</em> recovered. If you have any XTZ in that address, it will be lost forever.
</warning></p>
<p><warning>
If someone were to find your key and passphrase, they would have full access to the associated <code>tz</code> address. 
</warning></p>
<h3 id="cleanup">Clean up</h3>
<p>You should wipe the contents of the USB drive containing Ubuntu.</p>
<pre><code class="hljs bash language-bash">sudo dd <span class="hljs-keyword">if</span>=/dev/urandom of=/dev/disk2 bs=10m
</code></pre>
<p>Again, <em>double check</em> that this is the correct drive using the procedure above. This is a destructive procedure.</p>
<p>This operation will take a long time, depending on the size of your device.</p>
<h3 id="azure-key-import">Azure key import</h3>
<p>Now that we've securely generated our key and passphrase, we can import our key into the Azure Key Vault. We're going to follow a procedure very similar to the one we used for generating our keys, except this time we will not be able to air-gap this computer as it needs to talk to Azure.</p>
<p><warning>
Azure Key Vault does not offer a way to import keys with a key pair, which would be more secure than this method. That means your private key (and passphrase) will exist, in unencrypted form, in your machine's RAM until your computer is rebooted. If you are dealing with non-trivial amounts of XTZ, you should hire a security consultant.
</warning></p>
<p>This time, we will:</p>
<ol>
<li>Create a fresh installation of Ubuntu 18.04 on a USB drive</li>
<li>Run that on a computer with a network connection</li>
<li>Install and authenticate the Azure CLI</li>
<li>Import our key to Azure</li>
<li>Wipe our USB key</li>
</ol>
<p><note>
Ubuntu tends to be picky about WiFi adaptors. If possible, use a machine with a wired ethernet connection.
</note></p>
<h3 id="getazurerunningagain">Get Azure running (again)</h3>
<p>As above, install the CLI and then log in:</p>
<pre><code class="hljs bash language-bash">curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
az login
</code></pre>
<pre><code class="hljs plaintext language-plaintext">To sign in, use a web browser to open the page https://microsoft.com/devicelogin and enter the code XXXXXXXXX to authenticate.
</code></pre>
<p>Open a browser to the url that is returned and enter the code given.</p>
<h3 id="importyourkey">Import your key</h3>
<p>Use the following commands, adding in your desired key name, the name of the vault you've already created and the path to the encrypted <code>pem</code> file you've backed up on USB.</p>
<p>If you're creating a <code>tz2</code> address, you could use the following:</p>
<pre><code class="hljs bash language-bash"><span class="hljs-built_in">read</span> -sp <span class="hljs-string">"Passphrase: "</span> PASS; <span class="hljs-built_in">echo</span>; \
az keyvault key import \
    --name TezosSigner-KeyP256K \
    --vault-name TezosSigner-KeyVault \
    --ops sign \
    --pem-file secp256k1_sk.pem \
    --pem-password <span class="hljs-string">"<span class="hljs-variable">$PASS</span>"</span> \
    --protection hsm; \
<span class="hljs-built_in">unset</span> PASS
</code></pre>
<p>If you're creating a <code>tz3</code> address:</p>
<pre><code class="hljs bash language-bash"><span class="hljs-built_in">read</span> -sp <span class="hljs-string">"Passphrase: "</span> PASS; <span class="hljs-built_in">echo</span>; \
az keyvault key import \
    --name TezosSigner-KeyP256 \
    --vault-name TezosSigner-KeyVault \
    --ops sign \
    --pem-file prime256v1_sk.pem \
    --pem-password <span class="hljs-string">"<span class="hljs-variable">$PASS</span>"</span> \
    --protection hsm; \
<span class="hljs-built_in">unset</span> PASS
</code></pre>
<p><warning>
Do not copy and paste your passphrase from somewhere. Type it in by hand from the piece of paper you've written it on, which is the only place it should exist.
</warning></p>
<p>You should get output that looks like:</p>
<pre><code class="hljs bash language-bash">{
  ...
  <span class="hljs-string">"key"</span>: {
    <span class="hljs-string">"crv"</span>: <span class="hljs-string">"P-256"</span>,
    ...
    <span class="hljs-string">"keyOps"</span>: [
      <span class="hljs-string">"sign"</span>
    ],
    <span class="hljs-string">"kid"</span>: <span class="hljs-string">"https://&lt;URI&gt;/keys/TezosSigner-KeyP256/&lt;ID&gt;"</span>,
    <span class="hljs-string">"kty"</span>: <span class="hljs-string">"EC-HSM"</span>,
    ...
  },
  ...
}
</code></pre>
<p>Note the <code>crv</code> value, which should be <code>SECP256K1</code> for a <code>tz2</code> key and <code>P-256</code> for a <code>tz3</code> key.</p>
<p>Also take note of the <code>kty</code> property. Make sure that it is <code>EC-HSM</code> which means an elliptic curve key with HSM storage.</p>
<p>If you need to delete a key and start over, use e.g.:</p>
<pre><code class="hljs bash language-bash">az keyvault key delete \
    --name TezosSigner-KeyP256K \
    --vault-name TezosSigner-KeyVault
</code></pre>
<p>To list keys:</p>
<pre><code class="hljs bash language-bash">az keyvault key list \
    --vault-name TezosSigner-KeyVault
</code></pre>
<p>Now, remove your USB drive(s) and reboot your computer.</p>
<h3 id="cleanup-1">Clean up</h3>
<p>It is <em>strongly recommended</em> that you wipe the contents of the USB drive 
containing Ubuntu.</p>
<pre><code class="hljs bash language-bash">sudo dd <span class="hljs-keyword">if</span>=/dev/urandom of=/dev/disk2 bs=10m
</code></pre>
<p>Again, <em>double check</em> that this is the correct drive using the procedure above. This is a destructive procedure.</p>
<p>This operation will take a long time, depending on the size of your device.</p>
<h3 id="setting-up-signing-software">Setting up signing software</h3>
<p>The author has created signing software for this application with the following features:</p>
<ol>
<li>Supports <code>tz2</code> and <code>tz3</code> addresses</li>
<li>Allows whitelisting operations (e.g., baking and endorsing)</li>
<li>Checks high-water marks to ensure that it doesn't double-bake or double-endorse</li>
<li>Has a built in client to authorize other operations (transfers, voting, etc.)</li>
<li>The default settings are the most secure</li>
</ol>
<p>Non-features:</p>
<ol>
<li>Does not support high-availabilty setups where more than one baker or signer may be operating at the same time.</li>
</ol>
<h3 id="whynodejs">Why Node.js?</h3>
<p>A number of existing signers use the Python scripting language, so why use JavaScript instead? In short, Node has a more user-friendly system for handling versioning and package management. Installing Node and NPM-based software is hassle free in general.</p>
<h3 id="nodejssecurity">Node.js security?</h3>
<p>There have been a couple of recent cases of popular packages having malicious code added to them to target cryptocurrency private keys. The reasons the author still considers Node acceptable for this purpose:</p>
<ol>
<li>These exploits targeted popular wallets and <em>private keys</em>. This signer <em>does not</em> have access to your private keys</li>
<li>The group behind the NPM package manager maintains security audits of popular packages, updated regularly</li>
<li>Using <code>npm shinkwrap</code> ensures that the signer is installed with known safe versions of its dependencies</li>
</ol>
<p>You can run npm audit yourself:</p>
<pre><code class="hljs bash language-bash">npm audit
</code></pre>
<p>The output should look like:</p>
<pre><code class="hljs bash language-bash">...
found 0 vulnerabilities
 <span class="hljs-keyword">in</span> 1098 scanned packages
</code></pre>
<h3 id="installingnodejs">Installing Node.js</h3>
<p>SSH into your signer VM, if you haven't already:</p>
<pre><code class="hljs bash language-bash">ssh deploy@&lt;signer IP address&gt;
</code></pre>
<p>We're going to install Node version 10. We first need to add the repository and then install.</p>
<pre><code class="hljs bash language-bash">curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -
sudo apt-get install -y build-essential nodejs
</code></pre>
<p>If you have objections to piping installation scripts to bash, you can find instructions for manually installing here: <a href="https://github.com/nodesource/distributions/blob/master/README.md">https://github.com/nodesource/distributions/blob/master/README.md</a>.</p>
<p>Confirm installation:</p>
<pre><code class="hljs bash language-bash">node --version <span class="hljs-comment"># e.g., v10.16.0</span>
npm --version <span class="hljs-comment"># e.g., 6.9.0</span>
</code></pre>
<h3 id="installingthesigner">Installing the signer</h3>
<pre><code class="hljs bash language-bash">git <span class="hljs-built_in">clone</span> https://github.com/lattejed/tezos-azure-hsm-signer.git
<span class="hljs-built_in">cd</span> tezos-azure-hsm-signer
npm install
</code></pre>
<p>The response should look like:</p>
<pre><code class="hljs bash language-bash">added 307 packages from 666 contributors and audited 1098 packages <span class="hljs-keyword">in</span> 21.286s
found 0 vulnerabilities
</code></pre>
<h3 id="testingtheinstallation">Testing the installation</h3>
<p>We're first going to run the inlcluded tests, to make sure everything is working correctly.</p>
<pre><code class="hljs bash language-bash">npm run <span class="hljs-built_in">test</span>
</code></pre>
<p>The response should look like:</p>
<pre><code class="hljs bash language-bash">...
...
30 passing (38ms)
</code></pre>
<p>Now we're going to test our connection to our KeyVault. You'll need the Azure Key Vault URI from when we setup our Key Vault above. It should look like <code>https://&lt;...&gt;.vault.azure.net/</code>.</p>
<pre><code class="hljs bash language-bash">AZURE_KEYVAULT_URI=<span class="hljs-string">'https://tezossigner-keyvault.vault.azure.net/'</span> node server.js
</code></pre>
<p>If everything has been set up correctly, you should see output like:</p>
<pre><code class="hljs json language-json">{
  <span class="hljs-attr">"tz3..."</span>: {
    <span class="hljs-attr">"kid"</span>: <span class="hljs-string">"https://tezossigner-keyvault.vault.azure.net/keys/TezosSigner-KeyP256/..."</span>,
    <span class="hljs-attr">"pk"</span>: <span class="hljs-string">"p2pk..."</span>,
    <span class="hljs-attr">"pkh"</span>: <span class="hljs-string">"tz3..."</span>,
    <span class="hljs-attr">"signAlgo"</span>: <span class="hljs-string">"ES256"</span>
  }
}
</code></pre>
<p>The signing algorithm should be <code>ECDSA256</code> for <code>tz2</code> keys and <code>ES256</code> for <code>tz3</code> keys.</p>
<h3 id="finishingsignerinstallation">Finishing signer installation</h3>
<p>We're going to run our signing server as a daemon, using <code>systemd</code>. </p>
<pre><code class="hljs bash language-bash">cp tezos-signer.service.template tezos-signer.service
</code></pre>
<p>Now edit the <code>tezos-signer.service</code> file, adding in your vault URI at this line:</p>
<pre><code class="hljs bash language-bash">Environment = AZURE_KEYVAULT_URI=https://&lt;REPLACE ME&gt;.vault.azure.net/
</code></pre>
<p>When finished, do the following:</p>
<pre><code class="hljs bash language-bash">sudo cp tezos-signer.service /etc/systemd/system/tezos-signer.service
sudo systemctl <span class="hljs-built_in">enable</span> tezos-signer.service
sudo systemctl start tezos-signer.service
sudo systemctl status tezos-signer.service
</code></pre>
<p>Make sure you see a line starting <code>Active: active (running)...</code>. </p>
<h3 id="final-setup-and-testing">Final setup and testing</h3>
<p><highlight>TODO: Link to tezos alphanet setup.</highlight></p>
<p><warning>
It is <em>strongly recommended</em> that you first test out your signer on <code>zeronet</code> or <code>alphanet</code> using a test key.
</warning></p>
<p>Now that we've got our signer running, it's time to test it out against our baker node. </p>
<h3 id="settingupthefirewall">Setting up the firewall</h3>
<p>First, ensure that your default inbound rule is set to <code>Deny</code>:</p>
<pre><code class="hljs bash language-bash">az network nsg list \
    --resource-group TezosSigner-ResourceGroup \
    --query <span class="hljs-string">'[].defaultSecurityRules[].name'</span>
</code></pre>
<p>You should get output that looks like:</p>
<pre><code class="hljs json language-json">[
  ...
  <span class="hljs-string">"DenyAllInBound"</span>,
  ...
]
</code></pre>
<p><warning>
The string <code>DenyAllInBound</code> tells us we have to explicitly add inbound port rules, which is critical. Make sure it is there before using your signer.
</warning></p>
<p>Now, get the name of your network security group:</p>
<pre><code class="hljs bash language-bash">az network nsg list \
    --resource-group TezosSigner-ResourceGroup \
    --query <span class="hljs-string">'[].name'</span>
</code></pre>
<p>You should get a response like:</p>
<pre><code class="hljs json language-json">[
  <span class="hljs-string">"TezosSigner-VMNSG"</span>
]
</code></pre>
<p>Now, list your current rules.</p>
<pre><code class="hljs bash language-bash">az network nsg rule list \
    --nsg-name TezosSigner-VMNSG \
    --resource-group TezosSigner-ResourceGroup
</code></pre>
<p>The results should look like this:</p>
<pre><code class="hljs json language-json">[
  {
    "access": "Allow",
    ...
    "destinationPortRange": "22",
    "direction": "Inbound",
    ...
    "name": "default-allow-ssh",
    "priority": 1001,
    ...
    "sourceAddressPrefix": "*",
  }
]
</code></pre>
<p>This is the ssh rule we added when the VM was created. It basically says allow any inbound address to connect to port 22.</p>
<p>Now, let's add a rule to allow our baker to access our VM. We're going to pick a priority of 1001 as the default ssh rule should have a priority of 1000 and each rule's priority must be unique. If you add additional rules, use 1002, etc.</p>
<p>Let's say your baker's IP is 127.127.127.127, the command could look like this:</p>
<pre><code class="hljs bash language-bash">az network nsg rule create \
    --name Rule_127_127_127_127__6732 \
    --nsg-name TezosSigner-VMNSG \
    --resource-group TezosSigner-ResourceGroup \
    --priority 1001 \
    --access Allow \
    --destination-port-ranges 6732 \
    --<span class="hljs-built_in">source</span>-address-prefixes 127.127.127.127
</code></pre>
<p>If you move your baker, you <em>must</em> delete this rule, using:</p>
<pre><code class="hljs bash language-bash">az network nsg rule delete \
    --name Rule_127_127_127_127__6732 \
    --nsg-name TezosSigner-VMNSG \
    --resource-group TezosSigner-ResourceGroup
</code></pre>
<h3 id="testingoutthefirewall">Testing out the firewall</h3>
<p>Now, let's test that our firewall will reject requests from everywhere except our baker. From a machine that's not your baker, run the following:</p>
<pre><code class="hljs bash language-bash">curl --connect-timeout 10 http://&lt;signer VM address&gt;:6732/keys/&lt;tz address&gt;
</code></pre>
<p>After ten seconds, you should get a response like:</p>
<pre><code class="hljs plaintext language-plaintext">curl: (28) Connection timed out after 10001 milliseconds
</code></pre>
<p>If you get any other response, do not use your signer until you've diagnosed the problem.</p>
<h3 id="importingthekey">Importing the key</h3>
<p>Now, from your baker, issue the following command:</p>
<pre><code class="hljs bash language-bash">tezos-client import secret key my_azure_key http://&lt;signer IP address&gt;:6732/&lt;tz address&gt;
</code></pre>
<p>The response should be:</p>
<pre><code class="hljs plaintext language-plaintext">Tezos address added: &lt;tz address&gt;
</code></pre>
<h3 id="testingthekey">Testing the key</h3>
<p><highlight>TODO: Link to tezos alphanet setup.</highlight></p>
<p>To test that our setup is safe to use, we're going to transfer a small amount of XTZ to it (e.g., 1 xtz) from an existing address and then transfer it back. This assumes that you already have an account and key set up on your baker node.</p>
<pre><code class="hljs bash language-bash">tezos-client transfer 1 from my_account to my_azure_key
</code></pre>
<p><note>
It's always a good idea to first test a transaction by appending <code>--dry-run</code> to it. This will execute all parts of the transaction other than injecting it into the network.
</note></p>
<p>You may get an error transferring to your new address that looks like:</p>
<pre><code class="hljs plaintext language-plaintext">Fatal error:
  The operation will burn 0.257 which is higher than the configured burn cap ( 0).
   Use `--burn-cap 0.257` to emit this operation.
</code></pre>
<p>This is the cost of a "reveal" operation, where a new account has its public key included in the blockchain. This is a one time <em>storage fee</em> for newly created accounts. To allow this transaction, add the <code>--burn-cap 0.257</code> flag to the end of the <code>transfer</code> command.</p>
<p>You should get a confirmation. Check the balance of your new account with:</p>
<pre><code class="hljs bash language-bash">tezos-client get balance <span class="hljs-keyword">for</span> my_azure_key
</code></pre>
<p>Make sure the balance has been updated before continuing.</p>
<p><em>Before</em> we transfer back, we're going to have to start the <code>client</code> of our signer. From your signer VM, do the following:</p>
<pre><code class="hljs bash language-bash"><span class="hljs-built_in">cd</span> tezos-azure-hsm-signer    
node client.js
</code></pre>
<p>You should see:</p>
<pre><code class="hljs plaintext language-plaintext">Waiting for signing request. Ctrl-C to quit.
</code></pre>
<p><warn>
You <em>have to</em> start your signer client <em>before</em> you attempt a transaction. By design, it will ignore any signing requests that have been made before it was started.
</warn></p>
<p>Now, from your node:</p>
<pre><code class="hljs bash language-bash">tezos-client transfer 0.5 from my_azure_key to my_account
</code></pre>
<p>We're only going to transfer half of the amount back so we can ignore the fee calculation. You should get the following prompt on your <code>client</code>:</p>
<pre><code class="hljs plaintext language-plaintext">Confirm transaction 03... [Ny]?
</code></pre>
<p>Press <code>y</code> to accept it.</p>
<p>You should get a response that looks like:</p>
<pre><code class="hljs plaintext language-plaintext">The operation has only been included 0 blocks ago.
We recommend to wait more.
Use command
  tezos-client wait for XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX to be included --confirmations 30 --branch XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
and/or an external block explorer.
</code></pre>
<p><warning>
If you were not able to transfer XTZ in <em>and</em> out of your new <code>tz</code> address, <em>DO NOT</em> use it until you've diagnosed the problem.
</warning></p>
<p>If you made it this far, congratulations on your new HSM signer.</p>
<div class="navigation navigation-bottom">
  <ul>
    <li style="text-align: left">
      
        <a id="prevlink" href="/baking-tezos-privately.html">Baking Tezos Privately</a>
      
    </li>
    <li style="text-align: center">
      <a href="/toc.html">Table of Contents</a>
    </li>
    <li style="text-align: right">
      
        <a id="nextlink" href="/baking-tezos-publicly.html">Baking Tezos Publicly</a>
      
    </li>
  </ul>
</div>

      <div id="footer">
        <hr>
        <p class="license">This work is licensed under the Creative Commons license <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/">CC BY-NC-SA 3.0</a></p>
        <p class="license">By reading this site, you agree to the <a href="/terms.html">terms</a></p>
        
          <p class="timestamp">Page last updated Saturday, Jun 15, 2019</p>
        
      </div>
    </div><!-- #content -->
  </div><!-- #background -->
  <script src="/static/js/scripts.js"></script>
</body>
</html>
